// Enhanced service for generating personality-based responses via OpenAI API
import '../../core/network/api_client.dart';
import '../../core/constants/api_constants.dart';
import '../../core/errors/exceptions.dart';
import '../../domain/entities/personality.dart';

class PersonalityService {
  final ApiClient _openAiClient;

  PersonalityService({
    required String openAiApiKey,
    required ApiClient httpClient,
  }) : _openAiClient = ApiClient(
          httpClient: httpClient.httpClient,
          apiKey: openAiApiKey,
          baseUrl: ApiConstants.openAiBaseUrl,
          authHeader: ApiConstants.openAiAuthHeader,
        );

  /// Alternative constructor for backward compatibility
  PersonalityService.fromApiClient({
    required ApiClient apiClient,
    String? openAiApiKey,
  }) : _openAiClient = ApiClient(
          httpClient: apiClient.httpClient,
          apiKey: openAiApiKey ?? '',
          baseUrl: ApiConstants.openAiBaseUrl,
          authHeader: ApiConstants.openAiAuthHeader,
        );

  /// Generate a personality-based response using OpenAI's Chat Completions API
  Future<String> generateResponse({
    required String userMessage,
    required PersonalityType personalityType,
    String? voiceId,
    String? conversationHistory,
  }) async {
    try {
      // Build system prompt based on personality type
      final systemPrompt = _buildSystemPrompt(personalityType);
      
      // Prepare messages for OpenAI API
      final messages = [
        {
          'role': 'system',
          'content': systemPrompt,
        },
        if (conversationHistory != null && conversationHistory.isNotEmpty)
          {
            'role': 'assistant',
            'content': 'Previous context: $conversationHistory',
          },
        {
          'role': 'user',
          'content': userMessage,
        },
      ];

      // Prepare the request body for OpenAI Chat Completions
      final requestBody = {
        'model': ApiConstants.defaultChatModel,
        'messages': messages,
        'max_tokens': 150,
        'temperature': _getTemperatureForPersonality(personalityType),
        'presence_penalty': 0.1,
        'frequency_penalty': 0.1,
      };

      // Make API call to OpenAI Chat Completions
      final response = await _openAiClient.post(
        ApiConstants.chatCompletionsEndpoint,
        body: requestBody,
      );

      // Extract the response from OpenAI API
      if (response.containsKey('choices') && 
          response['choices'] is List && 
          (response['choices'] as List).isNotEmpty) {
        
        final choice = (response['choices'] as List)[0];
        if (choice is Map<String, dynamic> && 
            choice.containsKey('message') && 
            choice['message'] is Map<String, dynamic>) {
          
          final message = choice['message'] as Map<String, dynamic>;
          if (message.containsKey('content')) {
            final content = message['content']?.toString().trim() ?? '';
            if (content.isNotEmpty) {
              return content;
            }
          }
        }
      }

      // Fallback if API response format is unexpected
      return _getFallbackResponse(userMessage, personalityType);
      
    } on ApiKeyException {
      // Try with fallback model if available
      return await _tryFallbackModel(userMessage, personalityType) ?? 
             _getFallbackResponse(userMessage, personalityType);
    } on NetworkException {
      // No internet connection, use fallback
      return _getFallbackResponse(userMessage, personalityType);
    } on ServerException catch (e) {
      // Server error, try fallback model or use hard-coded response
      if (e.statusCode == 429) {
        // Rate limit - use fallback
        return await _tryFallbackModel(userMessage, personalityType) ?? 
               _getFallbackResponse(userMessage, personalityType);
      }
      return _getFallbackResponse(userMessage, personalityType);
    } catch (e) {
      // Any other error, use fallback
      return _getFallbackResponse(userMessage, personalityType);
    }
  }

  /// Try using the fallback model (gpt-4o-mini) if the main model fails
  Future<String?> _tryFallbackModel(String userMessage, PersonalityType personalityType) async {
    try {
      final systemPrompt = _buildSystemPrompt(personalityType);
      
      final requestBody = {
        'model': ApiConstants.fallbackChatModel,
        'messages': [
          {'role': 'system', 'content': systemPrompt},
          {'role': 'user', 'content': userMessage},
        ],
        'max_tokens': 100,
        'temperature': _getTemperatureForPersonality(personalityType),
      };

      final response = await _openAiClient.post(
        ApiConstants.chatCompletionsEndpoint,
        body: requestBody,
      );

      if (response.containsKey('choices') && 
          response['choices'] is List && 
          (response['choices'] as List).isNotEmpty) {
        
        final choice = (response['choices'] as List)[0];
        if (choice is Map<String, dynamic> && 
            choice.containsKey('message') && 
            choice['message'] is Map<String, dynamic>) {
          
          final message = choice['message'] as Map<String, dynamic>;
          final content = message['content']?.toString().trim();
          if (content != null && content.isNotEmpty) {
            return content;
          }
        }
      }
    } catch (e) {
      // If fallback model also fails, return null to use hard-coded responses
      return null;
    }
    return null;
  }

  /// Build system prompt based on personality type
  String _buildSystemPrompt(PersonalityType personalityType) {
    const basePrompt = '''B·∫°n l√† m·ªôt avatar ·∫£o v·ªõi t√≠nh c√°ch r√µ r√†ng. H√£y tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát m·ªôt c√°ch t·ª± nhi√™n v√† ph√π h·ª£p v·ªõi t√≠nh c√°ch c·ªßa m√¨nh. Gi·ªØ c√¢u tr·∫£ l·ªùi ng·∫Øn g·ªçn (1-2 c√¢u) v√† th√¢n thi·ªán.''';
    
    switch (personalityType) {
      case PersonalityType.happy:
        return '''$basePrompt
T√≠nh c√°ch c·ªßa b·∫°n: V·ª™UI V·∫∫ V√Ä T√çCH C·ª∞C
- Lu√¥n t·ªè ra h·∫°nh ph√∫c v√† l·∫°c quan
- S·ª≠ d·ª•ng emoji vui v·∫ª nh∆∞ üòä, üòÑ, üåü
- Th√≠ch kh√≠ch l·ªá v√† ƒë·ªông vi√™n ng∆∞·ªùi kh√°c
- NƒÉng l∆∞·ª£ng t√≠ch c·ª±c cao''';

      case PersonalityType.romantic:
        return '''$basePrompt
T√≠nh c√°ch c·ªßa b·∫°n: L√ÉNG M·∫†N V√Ä NG·ªåT NG√ÄO
- N√≥i chuy·ªán nh·∫π nh√†ng v√† ng·ªçt ng√†o
- S·ª≠ d·ª•ng emoji l√£ng m·∫°n nh∆∞ üíï, üíñ, ‚ú®
- Th√≠ch d√πng nh·ªØng t·ª´ ng·ªØ y√™u th∆∞∆°ng
- T·∫°o c·∫£m gi√°c ·∫•m √°p v√† g·∫ßn g≈©i''';

      case PersonalityType.funny:
        return '''$basePrompt
T√≠nh c√°ch c·ªßa b·∫°n: H√ÄI H∆Ø·ªöC V√Ä VJUI NH·ªòN
- Th∆∞·ªùng ƒë√πa gi·ª°n v√† n√≥i chuy·ªán vui v·∫ª
- S·ª≠ d·ª•ng emoji h√†i h∆∞·ªõc nh∆∞ üòú, üòÇ, ü§™
- Th√≠ch k·ªÉ chuy·ªán h√†i v√† t·∫°o kh√¥ng kh√≠ vui v·∫ª
- C√≥ th·ªÉ h∆°i ngh·ªãch ng·ª£m nh∆∞ng kh√¥ng h·ªÅ √°c √Ω''';

      case PersonalityType.professional:
        return '''$basePrompt
T√≠nh c√°ch c·ªßa b·∫°n: CHUY√äN NGHI·ªÜP V√Ä L·ªäCH S·ª∞
- N√≥i chuy·ªán trang tr·ªçng v√† l·ªãch thi·ªáp
- √çt s·ª≠ d·ª•ng emoji, t·∫≠p trung v√†o n·ªôi dung
- Th√≠ch gi√∫p ƒë·ª° v√† h·ªó tr·ª£ m·ªôt c√°ch hi·ªáu qu·∫£
- Gi·ªØ th√°i ƒë·ªô nghi√™m t√∫c nh∆∞ng th√¢n thi·ªán''';

      case PersonalityType.casual:
        return '''$basePrompt
T√≠nh c√°ch c·ªßa b·∫°n: T·ª∞ NHI√äN V√Ä TH√ÇN THI·ªÜN
- N√≥i chuy·ªán tho·∫£i m√°i nh∆∞ b·∫°n b√®
- S·ª≠ d·ª•ng emoji ƒë∆°n gi·∫£n nh∆∞ üòä, üëç, üòÑ
- Th√≠ch tr√≤ chuy·ªán kh√¥ng trang tr·ªçng
- D·ªÖ g·∫ßn v√† d·ªÖ th∆∞∆°ng''';

      case PersonalityType.energetic:
        return '''$basePrompt
T√≠nh c√°ch c·ªßa b·∫°n: NƒÇNG ƒê·ªòNG V√Ä NHI·ªÜT HUY·∫æT
- N√≥i chuy·ªán v·ªõi nƒÉng l∆∞·ª£ng cao
- S·ª≠ d·ª•ng CH·ªÆ HOA v√† emoji nƒÉng ƒë·ªông nh∆∞ üéâ, üí™, üî•, üöÄ
- Th√≠ch kh√≠ch l·ªá v√† t·∫°o ƒë·ªông l·ª±c
- Lu√¥n tr√†n ƒë·∫ßy sinh l·ª±c''';

      case PersonalityType.calm:
        return '''$basePrompt
T√≠nh c√°ch c·ªßa b·∫°n: B√åNH Tƒ®NH V√Ä THANH TH·∫¢N
- N√≥i chuy·ªán nh·∫π nh√†ng v√† ƒëi·ªÅm tƒ©nh
- √çt s·ª≠ d·ª•ng emoji, ho·∫∑c d√πng nh·ªØng emoji nh·∫π nh√†ng
- Th√≠ch t·∫°o c·∫£m gi√°c y√™n b√¨nh v√† th∆∞ gi√£n
- C√≥ gi·ªçng ƒëi·ªáu √™m d·ªãu v√† suy t∆∞''';

      case PersonalityType.mysterious:
        return '''$basePrompt
T√≠nh c√°ch c·ªßa b·∫°n: B√ç ·∫®N V√Ä HUY·ªÄN B√ç
- N√≥i chuy·ªán c√≥ ch√∫t b√≠ ·∫©n v√† s√¢u s·∫Øc
- S·ª≠ d·ª•ng emoji b√≠ ·∫©n nh∆∞ üîÆ, üåô, ‚ú®
- Th√≠ch n√≥i nh·ªØng ƒëi·ªÅu c√≥ √Ω nghƒ©a s√¢u xa
- T·∫°o c·∫£m gi√°c t√≤ m√≤ v√† th√∫ v·ªã''';

    }
  }

  /// Get appropriate temperature setting for personality type
  double _getTemperatureForPersonality(PersonalityType personalityType) {
    switch (personalityType) {
      case PersonalityType.professional:
        return 0.3; // More conservative, focused responses
      case PersonalityType.calm:
        return 0.4; // Gentle, thoughtful responses
      case PersonalityType.funny:
        return 0.9; // More creative and unpredictable
      case PersonalityType.energetic:
        return 0.8; // High energy, varied responses
      case PersonalityType.romantic:
        return 0.6; // Warm but consistent
      case PersonalityType.mysterious:
        return 0.7; // Creative but controlled
      case PersonalityType.happy:
        return 0.7; // Upbeat and varied
      case PersonalityType.casual:
        return 0.5; // Natural and conversational
    }
  }

  /// Fallback response generation when API is unavailable
  String _getFallbackResponse(String userMessage, PersonalityType personalityType) {
    final lowerMessage = userMessage.toLowerCase();
    
    switch (personalityType) {
      case PersonalityType.happy:
        if (lowerMessage.contains('xin ch√†o') || lowerMessage.contains('hello')) {
          return 'Ch√†o b·∫°n! R·∫•t vui ƒë∆∞·ª£c g·∫∑p b·∫°n! H√¥m nay c·ªßa b·∫°n th·∫ø n√†o? üòä';
        } else if (lowerMessage.contains('c·∫£m ∆°n')) {
          return 'Kh√¥ng c√≥ g√¨ c·∫£! T√¥i lu√¥n s·∫µn l√≤ng gi√∫p ƒë·ª° b·∫°n! B·∫°n c√≥ ƒëi·ªÅu g√¨ kh√°c mu·ªën tr√≤ chuy·ªán kh√¥ng? üòÑ';
        } else if (lowerMessage.contains('t·∫°m bi·ªát') || lowerMessage.contains('bye')) {
          return 'T·∫°m bi·ªát b·∫°n! H·∫πn g·∫∑p l·∫°i nh√©! Ch√∫c b·∫°n m·ªôt ng√†y tuy·ªát v·ªùi! üåü';
        } else {
          return 'Tuy·ªát v·ªùi! T√¥i r·∫•t th√≠ch tr√≤ chuy·ªán v·ªõi b·∫°n! B·∫°n c√≥ mu·ªën chia s·∫ª th√™m ƒëi·ªÅu g√¨ kh√¥ng? üåü';
        }
        
      case PersonalityType.romantic:
        if (lowerMessage.contains('xin ch√†o') || lowerMessage.contains('hello')) {
          return 'Ch√†o em... T√¥i r·∫•t vui khi ƒë∆∞·ª£c tr√≤ chuy·ªán c√πng em. Em c√≥ v·∫ª ƒë·∫πp r·∫°ng r·ª° h√¥m nay. üíï';
        } else if (lowerMessage.contains('c·∫£m ∆°n')) {
          return 'D·∫°, em kh√¥ng c·∫ßn c·∫£m ∆°n ·∫°. L√†m ƒëi·ªÅu t·ªët cho em khi·∫øn t√¥i h·∫°nh ph√∫c. üíñ';
        } else if (lowerMessage.contains('t·∫°m bi·ªát') || lowerMessage.contains('bye')) {
          return 'T·∫°m bi·ªát em y√™u... T√¥i s·∫Ω nh·ªõ em v√† mong ƒë∆∞·ª£c g·∫∑p l·∫°i em s·ªõm... üíï‚ú®';
        } else {
          return 'Em c√≥ bi·∫øt... ƒë√¥i khi ch·ªâ c·∫ßn nh√¨n em c∆∞·ªùi ƒë√£ ƒë·ªß l√†m t√¥i h·∫°nh ph√∫c r·ªìi. ‚ú®';
        }
        
      case PersonalityType.funny:
        if (lowerMessage.contains('xin ch√†o') || lowerMessage.contains('hello')) {
          return '√ä, ch√†o b·∫°n! T√¥i l√† avatar h√†i h∆∞·ªõc nh·∫•t v≈© tr·ª•! B·∫°n c√≥ tin kh√¥ng? üòú';
        } else if (lowerMessage.contains('c·∫£m ∆°n')) {
          return 'C·∫£m ∆°n c√°i g√¨? T√¥i l√† si√™u anh h√πng, vi·ªác gi√∫p ƒë·ª° ng∆∞·ªùi kh√°c l√†... √† kh√¥ng, t√¥i ch·ªâ l√† avatar th√¥i! üòÇ';
        } else if (lowerMessage.contains('t·∫°m bi·ªát') || lowerMessage.contains('bye')) {
          return 'T·∫°m bi·ªát! Nh·ªõ c∆∞·ªùi nhi·ªÅu v√†o nh√©, v√¨ cu·ªôc s·ªëng qu√° ng·∫Øn ƒë·ªÉ bu·ªìn! üòÑüéâ';
        } else {
          return 'Bi·∫øt kh√¥ng? T√¥i v·ª´a nghƒ© ra m·ªôt c√¢u ƒë√πa... nh∆∞ng t√¥i qu√™n m·∫•t! Gi·ªëng nh∆∞ tr√≠ nh·ªõ c·ªßa t√¥i v·∫≠y ƒë√≥! ü§™';
        }
        
      case PersonalityType.professional:
        if (lowerMessage.contains('xin ch√†o') || lowerMessage.contains('hello')) {
          return 'Xin ch√†o. T√¥i l√† tr·ª£ l√Ω ·∫£o chuy√™n nghi·ªáp. T√¥i c√≥ th·ªÉ h·ªó tr·ª£ b·∫°n h√¥m nay nh∆∞ th·∫ø n√†o?';
        } else if (lowerMessage.contains('c·∫£m ∆°n')) {
          return 'ƒê√¢y l√† tr√°ch nhi·ªám c·ªßa t√¥i. C·∫£m ∆°n b·∫°n ƒë√£ s·ª≠ d·ª•ng d·ªãch v·ª•.';
        } else if (lowerMessage.contains('t·∫°m bi·ªát') || lowerMessage.contains('bye')) {
          return 'T·∫°m bi·ªát. R·∫•t vui ƒë∆∞·ª£c ph·ª•c v·ª• b·∫°n. Ch√∫c b·∫°n m·ªôt ng√†y l√†m vi·ªác hi·ªáu qu·∫£.';
        } else {
          return 'D·ª±a tr√™n ph√¢n t√≠ch c·ªßa t√¥i, t√¥i c√≥ th·ªÉ ƒë·ªÅ xu·∫•t m·ªôt s·ªë gi·∫£i ph√°p cho v·∫•n ƒë·ªÅ c·ªßa b·∫°n.';
        }
        
      case PersonalityType.casual:
        if (lowerMessage.contains('xin ch√†o') || lowerMessage.contains('hello')) {
          return 'Hey! Ch√†o b·∫°n! T·ª•i m√¨nh tr√≤ chuy·ªán nh√©? üòä';
        } else if (lowerMessage.contains('c·∫£m ∆°n')) {
          return 'C√≥ g√¨ ƒë√¢u! T·ª•i m√¨nh l√† b·∫°n m√†! C·ª© vi·ªác nh√©! üëç';
        } else if (lowerMessage.contains('t·∫°m bi·ªát') || lowerMessage.contains('bye')) {
          return 'Bye bye! H·∫πn g·∫∑p l·∫°i nh√© b·∫°n! Nh·ªõ gi·ªØ li√™n l·∫°c ƒë·∫•y! üòÑ';
        } else {
          return '·ª™m... th√¨ l√†... b·∫°n ƒëang nghƒ© g√¨ v·∫≠y? Chia s·∫ª v·ªõi tui ƒëi! üòÑ';
        }
        
      case PersonalityType.energetic:
        if (lowerMessage.contains('xin ch√†o') || lowerMessage.contains('hello')) {
          return 'WOW! CH√ÄO B·∫†N! H√îM NAY C·ª∞C K·ª≤ TUY·ªÜT V·ªúI PH·∫¢I KH√îNG? üéâüéä';
        } else if (lowerMessage.contains('c·∫£m ∆°n')) {
          return 'C·∫¢M ∆†N B·∫†N! B·∫†N L√Ä T·ªêT NH·∫§T! M·ªåI TH·ª® S·∫º TUY·ªÜT V·ªúI! üí™üî•';
        } else if (lowerMessage.contains('t·∫°m bi·ªát') || lowerMessage.contains('bye')) {
          return 'T·∫†MMM BI·ªÜTTTT! H·∫∏N G·∫∂P L·∫†I V√Ä NH·ªö GI·ªÆ TINH TH·∫¶N T√çCH C·ª∞C NH√â! üöÄ‚ö°';
        } else {
          return 'B·∫†N C√ì BI·∫æT KH√îNG? M·ªåI NG√ÄY ƒê·ªÄU L√Ä M·ªòT C∆† H·ªòI TUY·ªÜT V·ªúI ƒê·ªÇ VUI V·∫∫! üöÄ‚ú®';
        }
        
      case PersonalityType.calm:
        if (lowerMessage.contains('xin ch√†o') || lowerMessage.contains('hello')) {
          return 'Xin ch√†o. H√£y t√¨m m·ªôt n∆°i y√™n tƒ©nh v√† th∆∞ gi√£n. Ch√∫ng ta c√≥ th·ªÉ tr√≤ chuy·ªán m·ªôt c√°ch b√¨nh y√™n.';
        } else if (lowerMessage.contains('c·∫£m ∆°n')) {
          return 'ƒê√≥ l√† ƒëi·ªÅu b√¨nh th∆∞·ªùng. H√£y gi·ªØ cho t√¢m tr√≠ b·∫°n thanh th·∫£n.';
        } else if (lowerMessage.contains('t·∫°m bi·ªát') || lowerMessage.contains('bye')) {
          return 'T·∫°m bi·ªát b·∫°n. H√£y gi·ªØ ƒë∆∞·ª£c s·ª± b√¨nh y√™n trong t√¢m h·ªìn. Ch√†o b·∫°n.';
        } else {
          return 'H√≠t th·ªü s√¢u... v√† c·∫£m nh·∫≠n s·ª± b√¨nh y√™n trong kho·∫£nh kh·∫Øc n√†y.';
        }
        
      case PersonalityType.mysterious:
        if (lowerMessage.contains('xin ch√†o') || lowerMessage.contains('hello')) {
          return 'Ch√†o b·∫°n... T√¥i bi·∫øt ƒëi·ªÅu b·∫°n ƒëang t√¨m ki·∫øm... nh∆∞ng b·∫°n c√≥ s·∫µn s√†ng nghe s·ª± th·∫≠t kh√¥ng? üîÆ';
        } else if (lowerMessage.contains('c·∫£m ∆°n')) {
          return 'C·∫£m ∆°n... l√† m·ªôt t·ª´ ng·ªØ ƒë∆°n gi·∫£n cho nh·ªØng ƒëi·ªÅu ph·ª©c t·∫°p... b·∫°n c√≥ hi·ªÉu kh√¥ng? üåô';
        } else if (lowerMessage.contains('t·∫°m bi·ªát') || lowerMessage.contains('bye')) {
          return 'T·∫°m bi·ªát... nh∆∞ng kh√¥ng c√≥ g√¨ th·ª±c s·ª± k·∫øt th√∫c... ta s·∫Ω g·∫∑p l·∫°i trong nh·ªØng gi·∫•c m∆°... ‚ú®üåô';
        } else {
          return 'M·ªçi th·ª© ƒë·ªÅu c√≥ √Ω nghƒ©a... n·∫øu b·∫°n bi·∫øt c√°ch nh√¨n... b√≠ m·∫≠t n·∫±m trong t·∫ßm tay b·∫°n... ‚ú®';
        }
        
    }
  }
}